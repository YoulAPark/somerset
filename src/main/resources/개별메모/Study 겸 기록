1. 사용자 점에서 MyBatis가 DB와 어떻게 상호작용하는지?
	(1) client의 요청(페이지 클릭)
	(2) Controller에서 Client의 모든 요청을 수용
		- Controller의 역할 
			1. 복잡한 작업 요청받기
			2. DB와 통신하는 작업
			3. 그 외 다양한 수많은 업무에 대한 요청 받음
			
	(3) Controller가 홀로 감당하면 deCoupling 현상이 발생하게 됨 (역할분담이 되어있지않아, 비효율적임)
		- Service 클래스가 이 때 역할을 하게 된다.
	(4) Service 클래스의 역할
		- Service -> Mapper Interface -> DB에 질의할 쿼리문을 관리하는 Mapper파일에 또 요청을 보냄 -> Mapper파일은 DB와 직접적으로 상호작용 -> 해당 과정의 역순으로 Client에게 보냄

		
2. log4jdbc-log4je 
	참고 : https://kafcamus.tistory.com/23
	(1) 사용하는 이유
	Spring에서 SQL문을 실행한 로그를 효과적이고 직관적으로 볼 수 있게 해주는 라이브러리
	무언가를 실행했을 경우 Console창에 테이블의 열과 행을 출력해서 보여준다.
	
	(2) 사용하는 방법 : 라이브러리 추가, 로그 설정 파일 추가, JDBC 연결 정보 설정
		1. build.gradle에 의존성 라이브러리 추가
			
			[내용]
			implementation group: 'org.bgee.log4jdbc-log4j2', name: 'log4jdbc-log4j2-jdbc4.1', version: '1.16'
		
		2. properties 모아져 있는 곳
			혹은 application.properties가 위치한 곳에 log4Jdbc관련 properties를 저장해야 한다.
		
			[파일명] : log4jdbc.log4j2.properties
			[내용]
			log4jdbc.spylogdelegator.name=net.sf.log4jdbc.log.slf4j.Slf4jSpyLogDelegator
			log4jdbc.dump.sql.maxlinelength=0
			
			* maxlinelength 값은 0~90까지 설정 가능 => 0이면 다 나옴
			* properties 파일은 New - Other - United Text File로 생성
			
		3. application.properties로 이동한다
		
		4. spring.datasource.driver-class-name 의 속성을 [내용]과 같이 변경한다.
			
			[내용]
			spring.datasource.driver-class-name=net.sf.log4jdbc.sql.jdbcapi.DriverSpy
		
		5. spring.datasource.url의 속성을 [내용]과 같이 변경한다.
		
		
3. build.gradle에 의존성 라이브러리 추가 하는 방법
	(1) https://mvnrepository.com/ 접속
	(2) 검색창에 원하는 라이브러리 검색 ex)log4Jdbc
	(3) 원하는 version 클릭
	(4) Gradle 클릭(사용하고 있는 걸로 누르면 됨)
	(5) 하단의 dependencies 복사한 후 build.gradle에 붙여넣기
	
4. mapper.xml의 역할
	DB 쿼리문을 관리하여 DB와 상호작용을 하는 역할을 한다.
	사용하기 위해선 applications.properties에 mapper-location 지정을 해줘야한다.
	
5. mapper.xml 속성 의미
	[출처 : https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-SQL-Mapper-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95]
	(1) id = 각 SQL을 구분한다.
	
	(2) resultType = SELECT문 실행결과를 담을 객체.
					패키지 이름을 포함한 클래스 이름 또는 객체 alias 지정
					
					=> SQL의 select문을 실행하면 결과가 나옴. 이 결과들을 resultType 속성에 지정함
					=> (1) 패키지 이름을 포함한 전체 클래스명 지정 : ex) resultMap = "com.moopi.mvc.vo.project"
					=> (2) 객체 alias 지정 : ex) alias = "project"
					
					* myBatis에서는 select결과를 저장하기 위해 resultType에 지정된 클래스의 인스턴스를 생성함
						그리고 각 컬럼에 대응하는 setter를 호출한다.
						컬럼에 맞는 setter가 없으면 저장이 되지 않기때문에
						컬럼명이 PNO인데 setter가 setNo()일 경우
						SELECT PNO as NO
						as를 사용하여 별칭을 붙여준다.
					
	(3) resultMap = SELECT문 실행 결과를 담을 객체를 resultMap 으로 지정한다,
					<resultMap>을 따로 선언해줘야 함
					resultType과 resultMap 중 하나를 선택하면 된다.
					
					* resultType 에서 컬럼에 맞지 않는 setter가 없으면 저장이 안되기 때문에 별칭을 as 로 따로 붙여준다고 했었음
						이런 번거로움을 덜기위해 resultMap 속성을 이용한다.
						
						resultMap 각 엘리먼트 속성의 의미
						(1) <resultMap>.type = SELECT 결과를 저장할 클래스 이름 또는 MyBatis 설정파일에 설정된 alias
						(2) <resultMap>.id = resultMap의 id
						(3) <id> : 객체 식별자로 사용되는 프로퍼티
						(4) <id>.column : 컬럼명
						(5) <id>.property : 객체 프로퍼티명 (setter 메서드이름에서 set을 빼고 첫 알파벳을 소문자로 만든 이름)
						(6) <result> : 컬럼과 setter 연결 정의
						(7) <result>.column : 컬럼명
						(8) <result>.property : 객체 프로퍼티명 (setter 메서드이름에서 set을 빼고 첫 알파벳을 소문자로 만든 이름)
						(9) <result>.javaType : 컬럼 값을 특정 자바 객체로 변환할 때 사용
						
						ex)
						<resultMap type="project" id="projectResultMap">
							<id column="PNO" property="no"/>
							<result column="PNAME" property="title"/>
							<result column="CONTENT" property="content"/>
							<result column="STA_DATE" property="startDate" javaType="java.sql.Date"/>
						</resultMap>
						
						
						ex)
						<select id="selectList" resultMap="projectResultMap">
							SELECT A, B, C
							FROM USER
							ORDER BY PNO DESC
						</select>
						=> 정의한 resultMap(projectResultMap)은 resultMap 속성에 <resultMap>의 id를 지정해서 사용할 수 있다.
	(4) parameterType = 이 속성에 지정한 객체의 프로퍼티값이 SQL문의 입력 파라미터에 지정된다.
					
6. xml 속성 관련
	[example - mybook.xml]
	<select id="selectUser"	parameterType="String"	resultMap="userMapper">
		select 
				ID
			, NAME
			, EMAIL
		FROM user
		order by id ASC;
	</select>
	
	[example - UserDao]
	public User selectUser(String id);
	
	<select id>는 Dao의 메서드 명을 가리킨다.
	parameterType은 Dao의 메서드 뒤 String을 가리킨다.
	resultMap은 xml의 맨 위에 명시된 resultMap 중 어떤 것을 가지고 올 것인지를 가리킨다.
 
7. JQuery
		
	(1)	$(function() {
			A();
		})
		=> 시작하자마자 A()라는 기능을 실행하는 function
		
	(2)	function A(){
			
		}
		=> A()기능의 세부
		
	(3) self.location = "/product/getProduct";
		네비게이션역할. product의 getProduct()를 실행한다.
		
	(4) $("form").attr("action","주소").submit();

8. [MVC 패턴] 
	[출처] : https://daydreamer-92.tistory.com/
	(1)	Client : 화면인 jsp를 통하여 Controller를 부르는 역할을 한다.
	(2) Controller : 컨트롤러를 구현하고, Service를 호출하는 역할을 한다.			
	(3) Service : 메서드를 정의하고 Dao 객체를 선언한다.
		* Service 와 ServiceImpl의 차이
		Service는 Interface이고, ServiceImpl은 실제로 구현하는 구현체 역할을 한다.
	(4) DAO : 실제로 DB에 접근하여 데이터를 조작하는 역할만 수행한다.(mySQL)
	(5) DAO에서 받아온 데이터를 Client까지 가지고와야 화면에 출력이 된다.
	
9. [자세한 MVC 패턴] 
	[출처] : https://velog.io/@sumusb/Spring-Service-Layer%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0
	
	(1) Client
		- 화면인 jsp를 통하여 Controller를 부르는 역할을 한다.
		
	(2) Controller 
		- 컨트롤러를 구현하고, Service를 호출하는 역할을 한다.	
		- Client가 이용할 End Point
		- Client의 요청을 어떻게 처리할지 정의하는 곳
		- Client의 요청을 처리하고 어떻게 응답할지 결정하는 곳
		
	(3) Service
		- Business Logic이 들어있는 가장 중요한 Layer
		- 데이터 유효성 검사, 무결성 검사 등 꼭 필요한 Logic들이 포함된다.
	
	(4) DAO	
		- 실제로 DB에 접근하여 데이터를 조작하는 역할만 수행
		- 다양한 저장소(storage)에 데이터를 조회, 저장, 수정, 삭제하기 위한 모든 객체들의 Layer이다.
	
	재사용성 Service와 Service의 관계
	1. Service와 DAO는 1:1 Mapping 이다.
	2. Service에서 Service는 참조가 가능하다. 하지만 순환참조를 방지하기 위해서 계층구조가 명확해야한다.
	3. Controller에서 하나의 메서드를 수행하기 위해
		필요한 객체들을
		각 각의 Service에서 리턴받아 
		수행을 하기위한 Service에 전달만 해주면 되는것
		
10. Ajax

	$.ajax({
			type : "GET" 
		,	url : "/jdUser/getfile/selectGetFile.do"
		,	contentType : "application/x-www-form-urlencoded; charset=utf-8"
		,	success : function(res) {
				$(".manual_down").attr("href", res[0].value);
				$(".client_down").attr("href", res[1].value);
		},
			error : function(request, status, error) {
				alert("에러가 발생했습니다. 관리자에게 문의하시기 바랍니다");
			}
	});
	
	type : 보내는 타입을 GET방식으로 할지, POST방식으로 할지 결정
	url : "/내 프로젝트명/XML파일의 NameSpace/내가 불러올 XMl의 Query이름/.do
	dataType : 데이터를 어떻게 받을지 지정하는 부분 / 입력하지 않을 경우 알아서 자동으로 지정해준다.
	data : 파라미터 값을 넘겨줄 부분 / GET방식, POST방식에 따라 결정된다.
	contentType : 기본값
	success : 성공시에 'res'부분을 받아와 하단의 요청사항을 실행한다
	attr() : attributeName의 줄임말. 
			인자에 따라 2가지로 사용이 가능하다.
			1개일 때 속성값을 받아오고, 2개일 때 속성값을 요소에 부여한다.
			속성값을 가져오지 못할 경우 undefinded을 반환한다.
			
			쉽게 말해,
			$(".manual_down").attr("href", res[0].value);
			.manual_down 클래스에 attr()함수를 적용하여 href에 res[0].value 값을 넣는다
			
11. Logic 만들기
	1. xml 파일 생성하기
	2. xml 파일 토대로 VO(Value Object, 객체) 생성하기
		* VO(Value Object)란?
		DB 구성의 필드들을 VO의 Attribute로 하고, 해당 변수에 접근이 가능토록 Getter, Setter 메서드의 조합으로 클래스를 형성해야한다.
		쉽게말해, xml의 인스턴스들을 Getter(가져오는것), Setter(설정하는것) 가 가능하도록 VO에도 인스턴스들을 선언하는 것
	3. Client 작성. (JSP, Ajax)
	4. 컨트롤러 구현
		- Dispatcher의 역할을 한다.
		- Client의 요청을 컨트롤러에서 해당되는 로직을 호출하여 수행결과와 함께 응답함
		* @(Annotaion)
			(1) @Controller : controller 객체임을 선언함
			(2) @Resource : Service 영역의 접근을 위한 선언
			(3) @RequestMapping : 요청하는 url
								value 부분의 주소를 호출하면
								주소와 @RequestMapping 과 매핑되어 해당 메서드가 실행된다.
			(4) @RequestBody, @ResponseBody : ajax를 처리하기 위한 어노테이션
											json 데이터 포맷을 이용할때, mappingJackson HttpMessageConverter를 사용하여 JSON String을 javaClass(get, set)에 자동 맵핑이 되도록 반환해준다.
				- @RequestBody : Client 요청을 서버에서 처리한 후 메서드가 리턴하는 오브젝트를 messageConverters를 통해 JSON형태로 반환하여 리턴해주는 역할
				- @RequestBody : Client에서 JsonObject로 전송되는 파라미터를 자동으로 javaClass 형식으로 변환해준다.			
	5. Service, ServiceImpl을 선언하여 메서드를 정의한다.
	6. DAO를 선언하여 DB에 접근할 수 있도록 한다.	
	
	정리 : xml -> VO -> JSP -> Controller -> Service/ServiceImpl -> DAO와 DB연결	
			
12. JSP에서 DB로 데이터를 보낼때 방식 
	- post방식으로 가져오기 위해서 form을 지정해야한다. form안에있는 데이터를보낸다.

13. Controller
	- public String 과 public static void의 차이
		: String의 경우 return값을 보내지만, void의 경우 별도의 return값을 보내지 않는다.
	- model.addAtrritube의 역할	
		: DB에 있는 값을 model에 담아서 JSP로 보내기 위해 사용된다.
	- sqlSession
		: 말그대로 sql 세션과 이어지기 위한 수단. sqlSession이 있어야 DB와 이어진다.
		
14. 
			
[JAVA Interfaces]
	1.  (1)
			- map은 선언시 <Key, Value>로 값을 넣는다.
			- Key와 Value는 한 쌍 
			- key로 식별하고 value에 사용할 값을 넣음
			- key는 중복이 불가능하고, 동일한 key값으로 값을 두번 넣게 되면 최근에 넣은 값이 적용된다
	
		(2) Map<K,V>
			K (key) : 이 항목에 해당하는 키 값을 반환한다.
			V (Value) : 이 항목에 해당하는 값을 반환한다. 
			
		(3)	예시 및 Method Detail	
			
			- Map 안에 값 넣기 : Map.put(key,value);
			- Map 안의 값 가져오기 : Map.get(key);
			- Map 크기 확인 : Map.size();
			- Map 안의 내용 변경하기 : Map.replace(key, value);
			- Map 안에 특정 Key, Value 들었는지 확인 : Map.containsKey(key); / Map.containsValue(value);
			- Map의 크기가 0인지 확인 : Map.isEmpty();
			- Map 안의 내용 삭제 : Map.remove(key);
			- Key가 있으면 Value 없으면 default 호출 : Map.getOrDefault(key, default);
				* (Map에 key에 해당하는 값이 없을 경우 default 호출)
			- Key가 없거나 Value가 null일때만 삽입 : Map.putIfAbsent(key, value);
	
		(4) Map 선언이 가능한 종류 : HashMap, TreeMap, HashTable, LinkedHashMap
			(1) HashMap : Map안에서 key/value에 따른 순서 없음
			(2) TreeMap : key값에 따라 오름차순 정렬 / 시간이 오래 걸림
			(3) HashTable : key/value에 null을 넣을 수 있음
			(4) LinkedHashMap : 삽입 순서에 따라 정렬
			

15. Controller에서의 get()과 set()
	
	[ProductController.java]
		Product product	
		getProdName
		
	public String addProduct(Product product) throws Exception {
		
		(1) product.getProduct(prodNo);
			=> JSP에서 입력받은 값 중 prodNo를 가지고 온다.
			product.getProduct(prodName);
			=> JSP에서 입력받은 값 중 prodName을 가지고 온다.
	}
	
16. Controller에서의 redirect
	
	public String 테스트메서드() throws Exception {
		return "redirect:addProductPage";
	}
	
	=>  테스트메서드()를 실행 후 addProductPage로 말그대로 redirect(재전송)도와준다
		메서드 실행후 지정된 페이지가 열림
		
		
17. @RequestMapping / @GetMapping /	@PostMapping 의 차이점
	
	공통점 : HTTP 메소드 특정 변형
	
	(1)	@RequestMapping
		
		특징
		- 클래스와 메서드 레벨에서 사용이 가능하다
		
		ex) @RequestMapping("/admin/ListProduct")
			=> localhost:8080/admin/ListProduct
		
	(2) @GetMapping	
		* @RequestMapping(method = RequestMethod.GET)의 줄임말
		
		특징
		- 메서드에서만 사용가능
		- HTTP GET 요청
		- 주소에 파라미터가 노출된다
			
		ex1) @GetMapping("/getParameter") => localhost:8080/getParameter?id=1234&password=abcd
											 => 물음표 뒤에 부터가 파라미터
			public String getParameter(@RequestParam String id, @RequestParam String password){
				
				// 여기서 password라는 변수가 쓰인다면 매개변수는 다른 이름으로 password를 받아야한다.
				// 그렇게 되면 매핑이 되지 않으므로 @RequestParam(name= "password") pwd 라고 지정해주면
				// 들어오는 인자는 password라는 이름으로 매핑될거야 라는 뜻을 가지고 있다.
				
				System.out.println("id : "+id);
				System.out.println("password : "+password);
				
				return id+password; //여기서 return한 것들이 web에 띄워지게 된다
			}
	
		ex2) @GetMapping("/getMultiParameter")
			public SearchParam getMultiParameter(SearchParam searchParam){
			
			System.out.println(searchParam.getAccount());
			System.out.println(searchParam.getEmail());
			System.out.println(searchParam.getPage());
			
			// { "accoount" : "", "email" : "", "page" : 0 }
			// 	=> 이런 형태로 바꿔주기 위해 객체를 리턴한다
				=> 기본적으로 json을 내포하고 있기에 객체를 리턴할 경우 기본적으로 json을 리턴한다
			return searchParam;
	
	(3) @PostMapping
		* @RequestMapping(method = RequestMethod.POST)의 줄임말
		
		특징
		- HTTP POST 요청
		- 주소창에 파라미터가 노출되지 않는다.
		- 메서드와 같은 주소 매칭은 에러가 발생한다
		- @RequestMapping은 초기에 설정되고 클래스에 대한 주소 매칭이므로 겹쳐도 상관없다.
		
		ex1) @PostMapping(value = "/postMethod")
			public SearchParam postMethod(@RequestBody SearchParam searchParam){
										  => @RequestBody로 지정해줘야한다
				return searchParam;
			}
			
	(4) 어노테이션 정리
		HTTP Method					동작					URL 형태
		GET					조회 (SELECT * READ)			/user/{id}
		POST				생성 (CREATE)					/user
		PUT / PATCH			수정 (UPDATD) *CREATE			/user
		DELETE				삭제 (DELETE)					/user/{1}
		

18. 지훈 TIP
	
	1) RequestParam은 JSP body의 name을 가져온다.
		=> Ajax 사용시 다를 수 있음
	
	2) @RequestBody : VO에 지정된 변수들 중에서 JSP Form태그 안에 지정된 파라미터만을 가져옴

	3) Controller와 RestController에서 사용하는 Annotaion의 종류
							GET방식				POST방식
	Controller			@RequestParam			@ModelAttribute
	RestController		@Pathvariable			@RequestBody
						=> 단일객체				=> VO 묶음
	
	4) body안에 모든 태그들이 다 있다.
		ex) 테이블을 꾸미고, 값을 집어넣고 등
			<form> 태그도 들어있고